Day-39
--------
Multithreading
-----------------
what is a thread
-----------------
A thread is the smallest unit of execution within a process. think of it is a light weight sub process that can run concurrently with other threads with in the same program. Threads share the same memory space and resources of their parent process but can execute independently.

Real- world Analogy
-------------------
the restaurant is like your java program(process).
Chefs are like threads--->they work simultaneously on different tasks.
they share the same kitchen space(memory) and ingredients(resources).
each of chef can work on different dishes independently but simultaneously.

Technical Definition
--------------------
in java a thread is
1. an independent path of execution with in a program.
2. a light weight process that shares memory with other threads.
managed by the JVM.
capable of running concurrently with other threads.

Process vs Thread
------------------
1. independent program in execution               light-weight sub unit of process.
2. it occupies separate memory space.             it occupies shared memory space.
3. creation cost is high(expensive).              creation cost is low(lightweight).
4. complex communications(IPc Is required)        simple communication(shared memory).

ways to define a thread
-----------------------
there are two primary approaches to define a thread.

1. Thread subclassing.
----------------------
definition: creating a custom thread by extending the thread class and overriding its run method.

basic structure
---------------
class MyCutomThread extends Thread{
public void run(){
// your Thread logic goes here.
}
}
when to use Thread subclassing
-------------------------------
you need to modify the Thread behaviour beyond the run() method.
you want to add additional methods specific to your thread.
your class represents a thread-like entity conceptually.
you don't need to extend another class(java single inheritance limitation).

Thread Schedular
-------------------

if multiple Threads are waiting to execute then which thread will execute 1st is decided by "Thread Schedular" which is part of JVM

which algorithm or behaviour followed by Thread Schedular we cant expect exactly it is the JVM vendor dependent hence in multithreading examples we cant expect exact execution order and exact output.

difference between t.start() and t.run()
-----------------------------------------
in the case of t.start method a new Thread will be created which is responsible for the execution of run() method.
but in the case of t.run() no new Thread will be created and run() method will be executed just like a normal method by the main method.

after Starting a Thread we are not allowed to restart the same Thread once again otherwise we will get Runtime exception saying Illegal Thread state Exception. 

2. Defining a thread by implementing Runnable Interface
--------------------------------------------------------
definition:
creating a custom thread By implementing Runnable Interface and providing the thread logic in run() method.

basic structure
----------------
class MyTask implements Runnable{
public void run(){
// your Thread logic goes here
}
}

when to use Runnable interface
-------------------------------
your class already extends another class(java single inheritacne).
you want better separation of a task an thread management.
you plan to use Thread pools or executers
you want more flexibility in Thread creation
following Object-oriented design principles(composition over inheritance).

Best Approach to define a thread
--------------------------------
among two approaches of defining a Thread, implementing Runnable interface Approach is always recommended.

in the 1st approach our class should always extend Thread class there is no chance of extending any other class hence we are missing inheritance benefits.

But In the second approach while implementing Runnable interface we can extend some other class also hence implementing runnable mechanism is recommended to define a Thread.

Thread Priorites 
----------------
Every thread in java has some priority it may be default priority generated by JVM or explicitly provided by the programmer.

The valid range of Thread priority is 1 to 10 [but not 0 to 10]. where 1 is the min priority and 10 is the max priority.

Thread class defines the following constants to represent some standard priorities.

1. Thread.MIN_PRIORITY---1
2. Thread.MAX_PRIORITY---10
3. Thread.NORM_PRIORITY---5.

there are no constants like Thread.LOW_PRIORITY, Thread.High_PRIORITY
Thread Schedular uses these priorities while allocating CPU.
The Thread which is having MAX priority will get chance for 1st execution. 
if 2 threads are having the same priority then we can't expect the exact execution order it depends on Thread schedular whose behaviour is vendor dependent.

we can get and set the priority of a thread by using the following methods

1. public final int getPriority();

public void final setPriority(int newPriority);//
the allowed values are 1 to 10 otherwise we will get runtime exception saying Illegal Argument Exception.

getting and setting name of a thread
------------------------------------
--------------------------------------
EveryThread in java has some priority it may be provided explicitly by the programmer or automatically generated by JVM.
Thread class defines the following methods to get and set name of a Thread.

public final String getName();
2. public final void setName(String name);